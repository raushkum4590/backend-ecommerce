# E-Commerce Microservices - Complete Setup Guide

## Architecture Overview

This e-commerce application has been transformed into a microservices architecture with the following services:

### Services

1. **Eureka Server** (Port: 8761) - Service Discovery
   - Manages service registration and discovery
   - Dashboard: http://localhost:8761

2. **API Gateway** (Port: 8080) - Single Entry Point
   - Routes requests to appropriate services
   - Handles CORS
   - Load balancing

3. **User Service** (Port: 8081)
   - User registration and authentication
   - JWT token generation
   - Address management
   - Database: ecommerce_users

4. **Product Service** (Port: 8082)
   - Product CRUD operations
   - Category management
   - Vendor management
   - Database: ecommerce_products

5. **Cart Service** (Port: 8083)
   - Shopping cart management
   - Add/Remove items
   - Database: ecommerce_carts

6. **Order Service** (Port: 8084)
   - Order creation and management
   - Order status tracking
   - Database: ecommerce_orders

7. **Payment Service** (Port: 8085)
   - PayPal payment processing
   - Cash on delivery
   - Database: ecommerce_payments

## Prerequisites

- Java 17
- Maven 3.6+
- MySQL 8.0
- Docker (optional, for containerized deployment)

## Setup Instructions

### Option 1: Local Development (Without Docker)

1. **Start MySQL Database**
   - Ensure MySQL is running on localhost:3306
   - Default credentials: root/root

2. **Build All Services**
   ```bash
   cd microservices
   mvn clean install
   ```

3. **Start Services**
   - **Windows**: Run `start-microservices.bat`
   - **Manual**: Start services in order:
     1. Eureka Server
     2. User Service
     3. Product Service
     4. Cart Service
     5. Order Service
     6. Payment Service
     7. API Gateway

### Option 2: Docker Deployment

1. **Build and Start with Docker Compose**
   ```bash
   cd microservices
   docker-compose up --build
   ```

2. **Stop Services**
   ```bash
   docker-compose down
   ```

## API Endpoints

All requests should go through **API Gateway (http://localhost:8080)**

### User Service Endpoints
- POST `/api/users/register` - Register new user
- POST `/api/users/login` - User login
- GET `/api/users/{id}` - Get user by ID
- GET `/api/users/email/{email}` - Get user by email
- PUT `/api/users/{id}` - Update user
- GET `/api/addresses/user/{userId}` - Get user addresses
- POST `/api/addresses` - Add new address

### Product Service Endpoints
- GET `/api/products` - Get all products
- GET `/api/products/{id}` - Get product by ID
- GET `/api/products/category/{categoryId}` - Get products by category
- GET `/api/products/vendor/{vendorId}` - Get products by vendor
- GET `/api/products/search?keyword=xxx` - Search products
- POST `/api/products` - Create product
- PUT `/api/products/{id}` - Update product
- DELETE `/api/products/{id}` - Delete product
- PATCH `/api/products/{id}/stock?quantity=10` - Update stock

### Cart Service Endpoints
- GET `/api/cart/user/{userId}` - Get user's cart
- POST `/api/cart/add` - Add item to cart
- DELETE `/api/cart/remove/{userId}/{productId}` - Remove item
- DELETE `/api/cart/clear/{userId}` - Clear cart

### Order Service Endpoints
- GET `/api/orders/user/{userId}` - Get user orders
- GET `/api/orders/{id}` - Get order by ID
- POST `/api/orders` - Create new order
- PATCH `/api/orders/{id}/status?status=SHIPPED` - Update order status
- POST `/api/orders/{id}/cancel?reason=xxx` - Cancel order
- GET `/api/orders` - Get all orders (admin)

### Payment Service Endpoints
- POST `/api/payments` - Create payment
- GET `/api/payments/order/{orderId}` - Get payment by order
- PATCH `/api/payments/{id}/status` - Update payment status
- POST `/api/payments/cod/{orderId}` - Process cash on delivery

## Database Schema

Each service has its own database for proper microservices isolation:

- **ecommerce_users**: Users, Addresses
- **ecommerce_products**: Products, Categories, Vendors
- **ecommerce_carts**: Carts, CartItems
- **ecommerce_orders**: Orders, OrderItems
- **ecommerce_payments**: Payments

## Inter-Service Communication

Services communicate using:
- **REST APIs**: Synchronous communication
- **Spring Cloud OpenFeign**: Client-side load balancing
- **Eureka**: Service discovery

## Security

- JWT tokens for authentication (shared across services)
- Tokens generated by User Service
- Common module contains shared JWT utility

## Configuration

Update database credentials in each service's `application.properties`:

```properties
spring.datasource.username=your_username
spring.datasource.password=your_password
```

For PayPal, update in Payment Service:
```properties
paypal.client.id=your_client_id
paypal.client.secret=your_client_secret
```

## Monitoring

- **Eureka Dashboard**: http://localhost:8761
- Monitor all registered services and their status

## Testing

Example: Register a user and get products

```bash
# Register user (through API Gateway)
curl -X POST http://localhost:8080/api/users/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "username": "testuser",
    "password": "password123",
    "phoneNumber": "1234567890"
  }'

# Login
curl -X POST http://localhost:8080/api/users/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "password123"
  }'

# Get all products
curl http://localhost:8080/api/products
```

## Advantages of This Architecture

1. **Scalability**: Each service can be scaled independently
2. **Fault Isolation**: Failure in one service doesn't affect others
3. **Technology Flexibility**: Each service can use different technologies
4. **Independent Deployment**: Deploy services independently
5. **Better Organization**: Clear separation of concerns
6. **Database per Service**: True microservices pattern

## Next Steps

1. Add API documentation (Swagger/OpenAPI)
2. Implement distributed tracing (Zipkin/Sleuth)
3. Add circuit breakers (Resilience4j)
4. Implement message queues (RabbitMQ/Kafka) for async communication
5. Add centralized configuration (Spring Cloud Config)
6. Implement API rate limiting
7. Add comprehensive logging (ELK Stack)
8. Set up CI/CD pipeline

## Troubleshooting

**Services not registering with Eureka**
- Wait 30 seconds after Eureka starts
- Check Eureka dashboard at http://localhost:8761

**Database connection errors**
- Verify MySQL is running
- Check credentials in application.properties
- Ensure databases are created (spring.jpa.hibernate.ddl-auto=update will create them)

**Port conflicts**
- Ensure ports 8080-8085 and 8761 are available
- Change ports in application.properties if needed

## Support

For issues or questions, refer to the individual service logs or the Eureka dashboard for service health status.

